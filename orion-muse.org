#+OPTIONS: ':nil *:t -:t ::t <:t H:3 \n:nil ^:{} arch:headline
#+OPTIONS: author:t c:nil creator:nil d:(not "LOGBOOK") date:t e:t
#+OPTIONS: email:nil f:t inline:t num:t p:nil pri:nil prop:nil stat:t
#+OPTIONS: tags:t tasks:t tex:t timestamp:t title:t toc:t todo:t |:t
#+TITLE: orion-muse
#+AUTHOR: William Henney
#+LANGUAGE: en
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
* TODO Important things to follow up
** [Fe III] 5270
+ This shows lots of wonderful structure in the jet source regions
  + HH529 and counterjet?
+ Also strong in NW extension of HH202
+ Shows jet that can be maybe linked with HH203/204
+ Our WFC3 469N filter shows a small field of this around Orion S
+ MUSE spectrum starts at 4595, so we should also have [Fe III] 4702, 4658, which are of similar brightness to 5270, plus a host of weaker ones - see the Manuel notes.
  + Yes, they are seen - 4658 is the best
** O II complex at 4650
+ 4649 and 4651 are severely blended
  + Disentangling these is vital for getting an O II density diagnostic
+ We have to sum over a large area to get enough s/n to fit for all the O II components
+ We could maybe use the mean wavelength of the 4649+51 blend as a proxy for the 4649/51 ratio, but we would have to correct for the kinematics, using perhaps [O III] or, better yet, an unblended line of the same multiplet
  + But the only one is  4676 and that is too weak
  + We can't really use 4639+42 because that is blended with N II 4643 and N III 4641
** [C I] 8727.13
+ This has a different morphology than anything else!
+ Redshifted filament pointing down SSW from Orion S
** [Ar III] 7135.78
+ This is excellent for velocity mapping
+ The velocity resolution is better at longer wavelengths
+ You can see blue-shifted and red-shifted flows easily
** Weaker lines that might be interesting
+ Ne I 8892.22 - similar to O I
+ Ca I] 9052.16 but 9095.09 is missing so maybe something else
+ [O I] 5577.31 need to remove sky line but then there are some interesting little spots like HH 201
+ 5906 very weak line - I had classified it as Si I 5906.22, 5906.15, 5906.418, 5906.92 but this seems very unlikely since it is not seen in any of the low-ionization parts, only near the Trapezium, most strongly in the SW compact bar
** Using the absorption lines
+ The trouble here is that many of the best He II lines are bluer than the spectral range
+ He II 4686 works well
  + Deepest in th2A
  + One problem is that it is phase-dependent in th1C
+ He II 5411 has some potential, but is contaminated by [Fe III]
+ O II 4650 is seen in absorbtion right on th2A, but in the nebula it is swamped by the ORL emission lines
+ C IV 5801.35, 5811.97 are clearly seen in th1C spectrum and much weaker in th2A, absent in other trapezium stars
  + Unfortunately, they are very weak in the nebula
  + Requires integration over 15x15 arcsec box to have much s/n
+ N III 6633.9 is very interesting
  + Has absorption depth of 0.08 in Orion S region
  + But not seen in any OB stars 
  + Seen in th1E, which is G2V spectral type
    + (which Olivares et al 2013) say is not bound to Trapezium
    + And is also eclipsing binary (Morales-CalderÃ³n et al 2012)
    + But absorption depth there is only 0.05
  + Conclusion must be that we are seeing scattered light from an embedded yellow supergiant that is leaking out.
  + Some T Tauri stars show a Cr I line at 6630 but that has a very low EW ~0.01 A (Apenzeller et al 1986, Table III)
  + There are also lines around 6480 and 6490 in the nebular scattered light
    + Some stars show a strongish line around 6495
+ Not an absorption line, but also possibly stellar
  + Wide (50 Angstrom) bup seen around 8600 Angstrom

** DONE Looking at the strange broad NIR emission bump
CLOSED: [2015-08-13 Thu 11:15]
+ Take the difference or ratio between 8570 A and 8552 A
+ Results are very disappointing
  + We see a vague form of the nebula in the ratio image
  + It looks similar to the continuum image, but not exactly the same
  + It doesn't look much like scattered continuum
  + And there is this instrumental tartan pattern superimposed on it
  + And it is also very noisy
  + Certainly not worth bothering with
  + Ratio image is even worse
#+BEGIN_SRC python :results output
  from astropy.io import fits
  import numpy as np

  cubehdu, = fits.open('muse-hr-data-wavsec6.fits')
  continuum = np.nanmean(cubehdu.data[441:446], axis=0)
  bump = np.nanmean(cubehdu.data[455:471], axis=0)
  fits.PrimaryHDU(header=cubehdu.header, data=bump-continuum).writeto('bump8600-diff.fits', clobber=True)
  fits.PrimaryHDU(header=cubehdu.header, data=bump/continuum).writeto('bump8600-ratio.fits', clobber=True)
#+END_SRC

#+RESULTS:

** Longer wavelength lines
| 7001.92 | O I      | 3 |                          |
| 7002.23 | O I      | 3 | blend                    |
| 7065.28 | He I     | 2 |                          |
| 7135.78 | [Ar III] | 1 | super strong             |
| 7155.14 | [Fe II]  | 4 |                          |
| 7231.34 | C II     | 3 |                          |
| 7236.42 | C II     | 3 |                          |
| 7254.15 | O I      | 3 | Also 7254.45, 7254.53    |
| 7281.35 | He I     | 3 |                          |
|  7290.3 | ?        | 4 | possibly [Fe II]         |
| 7318.39 | [O II]   | 1 | Also 7319.99             |
| 7329.66 | [O II]   | 1 | Also 7330.73             |
| 7377.83 | [Ni II]  | 4 |                          |
| 7411.61 | [Ni II]  | 5 |                          |
| 7442.30 | N I      | 5 |                          |
| 7452.54 | [Fe II]  | 4 |                          |
| 7468.31 | N I      | 4 |                          |
|---------+----------+---+--------------------------|
| 7751.10 | [Ar III] | 1 |                          |
| 7816.13 | He I     | 4 |                          |
| 7890.07 | Ca I]    | 4 |                          |
|    7900 | Sky      | 4 | Lots of sky lines        |
|    8000 | Sky      | 4 | in this spectral         |
|    8100 | Sky      | 4 | range                    |
|---------+----------+---+--------------------------|
|    8189 | Fe I?    | 4 | ID uncertain             |
| 8200.36 | N I?     | 5 | very weak                |
| 8210.72 | N I      | 5 |                          |
| 8216.34 | N I      | 4 |                          |
| 8223.14 | N I      | 4 | Strongest component      |
|    8243 | ?        | 4 | O I? or Fe II?           |
|   8240+ | H I      | 4 | Lots of Paschen lines    |
| 8437.96 | H I      | 3 | Pa 18                    |
| 8446.36 | O I      | 2 | And 8444.25, 8444.76--   |
| 8467.25 | H I      | 2 | Pa 17                    |
| 8502.48 | H I      | 2 | Pa 16                    |
| 8545.38 | H I      | 2 | Pa 15                    |
| 8578.69 | [Cl II]  | 3 |                          |
| 8598.39 | H I      | 2 | Pa 14                    |
|    8600 | Bump?    | 4 | Maybe scattered stellar  |
| 8616.95 | [Fe II]  | 3 |                          |
| 8665.02 | H I      | 2 | Pa 13                    |
| 8680.28 | N I      | 4 | Strongest component      |
| 8683.40 | N I      | 4 |                          |
| 8686.15 | N I      | 4 |                          |
| 8703.25 | N I      | 4 |                          |
| 8711.70 | N I      | 4 |                          |
| 8718.83 | N I      | 5 | very weak                |
| 8727.13 | [C I]    | 4 | Different!               |
| 8733.43 | He I     | 5 | very weak                |
| 8750.47 | H I      | 2 |                          |
|---------+----------+---+--------------------------|
| 8862.79 | H I      | 2 |                          |
| 8892.22 | Ne I     | 4 |                          |
| 8996.99 | He I     | 5 |                          |
| 9014.91 | H I      | 2 | Pa 10                    |
|    9036 | ?        | 5 | very low ionization      |
| 9052.16 | Ca I]    | 5 |                          |
| 9068.90 | [S III]  | 1 |                          |
| 9095.09 | Ca I]    | 5 |                          |
| 9123.60 | [Cl II]  | 4 |                          |
| 9204.17 | O II?    | 5 | but looks low ionization |
| 9210.28 | He I     | 4 |                          |
| 9229.01 | H I      | 2 | Pa 9                     |
* Extracting lines for comparison with WFC3
:LOGBOOK:
CLOCK: [2015-10-07 Wed 09:58]
:END:
+ The interesting sections are wavsec0 to wavsec3

** Extract subsets of the full cubes

*** PV diagrams
Not yet

*** Spectral windows for each WFC3 filter
:PROPERTIES:
:header-args: :python /Users/will/anaconda/envs/py27/bin/python :preamble "from __future__ import print_function" :noweb yes
:END:

+ In principal the calibration can be done with just integrating the spectrum over the filter T reponse.
+ But we really need to fit Gaussians to the lines
+ Note that pysynphot requires Python 2.7
+ Also requires PYSYN_CDBS environment variable to be set
  + On linux server
#+BEGIN_SRC sh
export PYSYN_CDBS=/fs/nil/other0/will/CDBS
#+END_SRC


**** List of HST filters to use
:PROPERTIES:
:TABLE_EXPORT_FILE: all-filters-input.tab
:TABLE_EXPORT_FORMAT: orgtbl-to-tsv
:END:

Export this table to [[file:all-filters-input.tab]] with =C-c t e= after any modification. 

#+name: selected-filters
| Instrument | Filter |
|------------+--------|
| wfc3       | f469n  |
| wfc3       | f487n  |
| wfc3       | f502n  |
| wfc3       | f547m  |
| wfc3       | fq575n |
| wfc3       | f656n  |
| wfc3       | f658n  |
| wfc3       | fq672n |
| wfc3       | f673n  |
| wfc3       | fq674n |
|------------+--------|
| wfpc2      | f502n  |
| wfpc2      | f547m  |
| wfpc2      | f631n  |
| wfpc2      | f656n  |
| wfpc2      | f658n  |
| wfpc2      | f673n  |
|------------+--------|
| acs        | f658n  |
| acs        | f660n  |
| acs        | f435w  |
| acs        | f555w  |
| acs        | f775w  |
| acs        | f850lp |


Send all tables to linux server
#+BEGIN_SRC sh :results verbatim
rsync -aPq *.tab nil:/fs/nil/other0/will/orion-muse
#+END_SRC

#+RESULTS:

#+name: bandpass-fullname-function
#+BEGIN_SRC python
  def bp_fullname(instrument, filter_):
      if instrument.lower() == 'wfc3':
          return 'wfc3,uvis1,'+filter_.lower()
      elif instrument.lower() == 'acs':
          return 'acs,wfc1,'+filter_.lower()
      elif instrument.lower() == 'wfpc2':
          return 'wfpc2,'+filter_.lower()
      else:
          raise NotImplementedError('Unknown instrument: ' + instrument)
#+END_SRC


**** DONE [1/1] Print out the mean wavelength and rectangular width of each filter
CLOSED: [2015-10-08 Thu 11:25]
#+name: extract-bandpasses 
#+BEGIN_SRC python :return outtab
  import pysynphot
  from astropy.table import Table
  <<bandpass-fullname-function>>
  float_fmt = '{:.2f}'
  intab = Table.read('all-filters-input.tab', format='ascii.tab')
  outtab = [['Filter', 'Wav0', 'dWav'], None]
  for row in intab:
      fn = bp_fullname(row['Instrument'], row['Filter'])
      bp = pysynphot.ObsBandpass(fn)
      outtab.append([fn, float_fmt.format(bp.avgwave()), float_fmt.format(bp.rectwidth())])
#+END_SRC

#+RESULTS: extract-bandpasses
| Filter            |    Wav0 |    dWav |
|-------------------+---------+---------|
| wfc3,uvis1,f469n  | 4688.14 |   49.67 |
| wfc3,uvis1,f487n  | 4871.42 |   60.41 |
| wfc3,uvis1,f502n  | 5009.71 |   65.27 |
| wfc3,uvis1,f547m  | 5451.37 |  649.89 |
| wfc3,uvis1,fq575n | 5757.87 |   18.37 |
| wfc3,uvis1,f656n  | 6561.44 |   17.65 |
| wfc3,uvis1,f658n  | 6584.91 |   27.55 |
| wfc3,uvis1,fq672n | 6716.62 |   19.37 |
| wfc3,uvis1,f673n  | 6766.04 |  117.78 |
| wfc3,uvis1,fq674n | 6730.77 |   17.63 |
| wfpc2,f502n       | 5013.41 |   35.80 |
| wfpc2,f547m       | 5487.62 |  638.11 |
| wfpc2,f631n       | 6306.45 |   42.14 |
| wfpc2,f656n       | 6563.57 |   28.34 |
| wfpc2,f658n       | 6590.91 |   39.24 |
| wfpc2,f673n       | 6732.30 |   63.31 |
| acs,wfc1,f658n    | 6584.05 |   74.94 |
| acs,wfc1,f660n    | 6599.50 |   35.69 |
| acs,wfc1,f435w    | 4338.43 |  862.30 |
| acs,wfc1,f555w    | 5373.22 | 1124.61 |
| acs,wfc1,f775w    | 7705.71 | 1320.72 |
| acs,wfc1,f850lp   | 9049.59 | 1261.35 |

+ [X] Test that this works on linux server



**** Decomposing the components that go into the throughput curve

This is done in [[file:wfc3-throughput-components.py]]

Use the STScI python install for a change
#+BEGIN_SRC sh :results file :file wfc3-throughput-components.pdf
source ~/.bash_profile
ur_setup
export PYSYN_CDBS=/Users/will/Dropbox/CDBS
python wfc3-throughput-components.py
#+END_SRC

#+RESULTS:
[[file:wfc3-throughput-components.pdf]]

This is a plot of all the components that multiply together to make the filter throughput:
+ hst_ota :: Optical Telescope Assembly.  I think this is the primary mirror efficiency, accounting for fraction of circular area that is obscured by secondary. Roughly constant at about 0.65
+ wfc3_uvis_ccd1 :: Efficiency of CCD, roughly constant at ~ 0.87
  + Note that CCD2 is extremely similar.  The difference is less than 0.5%
+ wfc3_uvis_owin :: Outer window transmission, roughly 0.95
+ wfc3_uvis_cor :: Correction based on white dwarf photometry. Roughly 1.18 but falling to red.
+ wfc3_uvis_mir1 :: Internal camera mirror efficiency, roughly 0.9
+ wfc3_uvis_mir2 :: Another mirror efficiency, roughly 0.9
+ wfc3_uvis_iwin :: Internal window, roughly 0.95
+ wfc3_pom_001 :: Pick Off Mirror (45 deg mirror that diverts light into instrument), roughly 0.88
+ wfc3_uvis_f547m :: The filter itself, roughly 0.85 

Multiplying them all together gives the total transmission of src_calc{0.65 0.87 0.95 1.18 0.9 0.9 0.95 0.88 0.85} {{{results(=0.364878642843=)}}}, which matches what is expected for the total bandpass.


***** DONE Variation with time
CLOSED: [2015-10-13 Tue 09:23]
+ According to [[http://ssb.stsci.edu/pysynphot/docs/appendixb.html#pysynphot-appendixb][Appendix B of the pysynphot docs]] we can ask for the filter throughput for a particular MJD using e.g., 'wfc3,uvis1,f658n,mjd#49486'
+ Today's Julian date is src_calc{julian(<Tue Oct 13, 2015>) - 2400000} {{{results(=57307=)}}}
+ Orion S observations were around MJD=55933
+ Plot various dates in [[file:wfc3-throughput-evolution.py]]
#+BEGIN_SRC sh :results file :file wfc3-throughput-evolution.pdf
source ~/.bash_profile
ur_setup
export PYSYN_CDBS=/Users/will/Dropbox/CDBS
python wfc3-throughput-evolution.py
#+END_SRC

#+RESULTS:
[[file:wfc3-throughput-evolution.pdf]]

Upshot is that there is no discernible difference with time, and also that the Quantum Yield Correction makes no difference at the shortest wavelengths that we are interested in (4700 Angstrom), 

src_python{import sys; return sys.version.split(' ')[0]} {{{results(=2.7.10=)}}} 

**** TODO Converting surface brightness to predicted counts
+ Note that =bp.primary_area= is given as 45238.93416, which must be in sq cm.  This is same as src_calc{pi*(120)**2} {{{results(=45238.9342117=)}}} 
+ The units of the muse data is given as '10**(-20)*erg/s/cm**2/Angstrom'
  + This must be per pixel, I assume
  + Each pixel is 0.2 arcsec square, so this is src_calc{(0.2/206265)**2} {{{results(=9.40175455274e-13=)}}} steradian
+ [ ] We have summed this in wavelength, but we really should have multiplied by lambda first to convert from energy to photon units
  + And while we are at it we can use the C_{WFC3} to put it in electron/s



**** Air to vacuum wavelength conversion
+ This depends on refractive index of air, given by the following function
+ To convert air -> vacuum we multiply the wavelengths by the refractive index
+ 

#+name: air-refractive-index
#+BEGIN_SRC python
  from astropy import units as u
  def air_refractive_index(wav):
      """Equation (65) of Greisen et al 2006 for the refractive index of air
  at STP.  Input wavelength 'wav' should be in microns or in any
  'astropy.units' unit. It does not matter if 'wav' is on air or vacuum
  scale

      """
      try:
          # Convert to microns if necessary
          wavm = wav.to(u.micron).value
      except AttributeError:
          # Assume already in microns
          wavm = wav
      return 1.0 + 1e-6*(287.6155 + 1.62887/wavm**2 + 0.01360/wavm**4)

#+END_SRC
**** TODO [5/5] Process spectral windows for each filter
+ This could be the last step that we would have to run on the server
+ If the files are small enough then they can be copied over to the macs
+ Each of the following snippets is run interactively on the server
***** DONE Imports
CLOSED: [2015-10-08 Thu 12:00]
#+name: astro-imports
#+BEGIN_SRC python
  from astropy.io import fits
  from astropy import wcs
  from astropy.table import Table
  import pysynphot
  import numpy as np
#+END_SRC
***** DONE Read FITS cube
CLOSED: [2015-10-08 Thu 12:00]
#+BEGIN_SRC python
  hdulist = fits.open('DATA/DATACUBEFINALuser_20140216T010259_78380e1d.fits')
#+END_SRC
***** DONE Set up a vacuum wavelength scale
CLOSED: [2015-10-08 Thu 14:01]
#+namer: setup-wavs
#+BEGIN_SRC python
  <<air-refractive-index>>
  w = wcs.WCS(hdulist['DATA'].header)
  NV, NY, NX = hdulist['DATA'].data.shape
  # construct array of observed air wavelengths (at image center to be safe)
  _, _, wavs = w.all_pix2world([NX/2]*NV, [NY/2]*NV, np.arange(NV), 0) 
  # Make dimensional
  wavs *= u.m
  # Convert to vacuum scale
  wavs *= air_refractive_index(wavs)
#+END_SRC
***** DONE Read in the table of filters
CLOSED: [2015-10-08 Thu 14:08]
#+BEGIN_SRC python
  intab = Table.read('all-filters-input.tab', format='ascii.tab')
#+END_SRC
***** DONE Extract the windows for each filter
CLOSED: [2015-10-12 Mon 09:18]
#+BEGIN_SRC python
  <<bandpass-fullname-function>>
  for row in intab:
      bpname = bp_fullname(row['Instrument'], row['Filter'])
      bp = pysynphot.ObsBandpass(bpname)
      # extend a full rectwidth either side of the average wavelength to fit it all in
      wav_window = bp.avgwave() + bp.rectwidth()*np.array([-1, 1])
      # Add in the units (all are in Angstrom I hope)
      assert bp.waveunits.name == 'angstrom'
      wav_window *= u.Angstrom
      # convert to air wavelengths to agree with the WCS
      wav_window /= air_refractive_index(wav_window)
      # Now convert to fractional pixel coordinates
      _, _, [k1, k2] = w.all_world2pix([0, 0], [0, 0], wav_window.to(u.m), 0)
      # smallest slice that covers the window
      wavslice = slice(int(k1), int(k2) + 2)
      # tuple of slices for the 3 cube axes (in numpy array order: V, Y, X)
      cubeslices = [wavslice, slice(None, None), slice(None, None)]

      newhdr = hdulist['DATA'].header.copy()
      newhdr.update(w.slice(cubeslices).to_header())

      # Make a new HDUlist for the windowed spectrum and write it out
      fits.HDUList(
          [fits.PrimaryHDU(header=hdulist[0].header, data=None),
           fits.ImageHDU(header=newhdr, data=hdulist['DATA'].data[cubeslices])
          ]
      ).writeto('muse-hr-window-{}-{}.fits'.format(row['Instrument'], row['Filter']), clobber=True)
#+END_SRC
**** Cleaning up the window FITS files for DS9
For some reason, ds9 does not like the wavelength WCS, so we will try and fix it:
+ Put the physical scales in the CDELTi instead of in the PCi_j
+ Put it in angstrom instead of m
+ That's it to start with
#+BEGIN_SRC python :tangle clean_up_wav_wcs.py
  import sys
  from astropy.io import fits
  def clean_up_wav_wcs(filename):
      hdulist = fits.open(filename, mode='update')
      for hdu in hdulist:
          if hdu.header.get('CUNIT3') == 'm':
              # Change to Angstrom
              hdu.header['PC3_3'] *= 1e10
              hdu.header['CRVAL3'] *= 1e10
              hdu.header['CUNIT3'] = 'Angstrom'
              # And move scales to CDELT
              for i in '123':
                  CDELTi = 'CDELT'+i
                  # Sanity check
                  assert hdu.header.get(CDELTi) == 1.0
                  PCi_j = 'PC{0}_{0}'.format(i)
                  hdu.header[CDELTi], hdu.header[PCi_j] = hdu.header[PCi_j], hdu.header[CDELTi] 
      hdulist.flush()


  if __name__ == '__main__':
      try:
          fn = sys.argv[1]
          clean_up_wav_wcs(fn)
      except IndexError:
          print('Usage:', sys.argv[0], 'FITSFILE')
        
#+END_SRC
Export with =C-u C-c C-v C-t=

Test it on the WFC3 f656n file

#+BEGIN_SRC sh :results silent
python clean_up_wav_wcs.py muse-hr-window-wfc3-fq674n.fits
#+END_SRC

That seemed to work

#+BEGIN_SRC sh :results silent
python clean_up_wav_wcs.py muse-hr-window-wfc3-f487n.fits
#+END_SRC

**** DONE Convert from erg/cm2/s/Angstrom to electron/s
CLOSED: [2015-10-13 Tue 12:50]
:LOGBOOK:
- Note taken on [2015-10-13 Tue 09:58]
:END:
+ The fundamental equation is \(R_{}_j = C_{WFC3 }\int \lambda I_\lambda T_\lambda d\lambda\)
  + Where C_{WFC3 }= 0.0840241 if \lambda is in \AA
+ So, we need to multiply by lambda when we do the flattening
+ Also, we need to get from MUSE's flux-per-pixel to brightness (per-steradian)
  + This means we divide by the MUSE pixel area of 9.40175455274e-13 sr
+ AND we need to multiply by the MUSE bin width in \AA
+ Question is, do we apply this normalization to the =transwin= cubes?
  + Best not, so as to minimze churn of large files on Dropbox

#+name: flux-to-counts
#+BEGIN_SRC python
  from astropy import units as u
  WFC3_CONSTANT = 0.0840241
  MUSE_FLUX_UNITS = 1e-20 
  MUSE_PIXEL_AREA_SR = (0.2*u.arcsec).to(u.radian)**2

#+END_SRC
**** Fold the spectra through each filter to get simulated images
This does not have to be done on the server any more

#+BEGIN_SRC python :tangle filter-flatten.py 
  from __future__ import print_function
  import sys
  <<astro-imports>>
  <<air-refractive-index>>
  <<bandpass-fullname-function>>
  <<flux-to-counts>>

  def bandpass_flatten(instrument, bpname):
      filename = 'muse-hr-window-{}-{}.fits'.format(instrument, bpname)
      hdulist = fits.open(filename)
      hdu = hdulist['DATA']
      w = wcs.WCS(hdu.header)
      NV, NY, NX = hdu.data.shape
      # construct array of observed air wavelengths (at image center to be safe)
      _, _, wavs = w.all_pix2world([NX/2]*NV, [NY/2]*NV, np.arange(NV), 0) 
      # Make dimensional
      wavs *= u.m
      # Convert to vacuum scale
      wavs *= air_refractive_index(wavs)

      # Get bandpass for filter
      fn = bp_fullname(instrument, bpname)
      bp = pysynphot.ObsBandpass(fn)
      # Calculate transmission curve at the observed wavelengths
      T = bp(wavs.to(u.Angstrom).value)
      # Weight by transmission curve and save that
      hdu.data *= T[:, None, None]
      hdulist.writeto(filename.replace('-window-', '-transwin-'), clobber=True)
      # Integrate over wavelength, already weighted by transmission curve. But
      # now need to multiply by wavelength, put in brightness units, and
      # convert to WFC3 electron/s/pixel
      hdu.data *= WFC3_CONSTANT*MUSE_FLUX_UNITS/MUSE_PIXEL_AREA_SR
      hdu.data *= wavs.to(u.Angstrom).value[:, None, None]
      hdu.data = hdu.header['CDELT3']*np.sum(hdu.data, axis=0)
      hdu.header['BUNIT'] = 'electron/s/(0.03962 arcsec)**2'
      hdulist.writeto(filename.replace('-window-', '-image-'), clobber=True)

  if __name__ == '__main__':
      try:
          instrument, bpname = sys.argv[1:]
          bandpass_flatten(instrument, bpname)
      except IndexError:
          print('Usage:', sys.argv[0], 'INSTRUMENT FILTER')
  
#+END_SRC

New example of use, using STSCI python on laptop
#+BEGIN_SRC sh :results silent
source ~/.bash_profile
ur_setup
export PYSYN_CDBS=/Users/will/Dropbox/CDBS
python filter-flatten.py wfc3 fq575n
#+END_SRC


Check the same one using the Anaconda py27 on hypatia, but make sure that we are using the same version of CDBS
#+BEGIN_SRC sh :results silent
source activate py27
export PYSYN_CDBS=/Users/will/Dropbox/CDBS
python filter-flatten.py wfc3 fq575n
#+END_SRC
Exactly the same, which is a heartening.  

Now do it for all the filters
#+BEGIN_SRC sh
  source activate py27
  export PYSYN_CDBS=/Users/will/Dropbox/CDBS
  FILTERS="f469n f487n f502n f547m fq575n f656n f658n fq672n f673n fq674n"
  for f in $FILTERS; do
      echo Flattening $f
      python filter-flatten.py wfc3 $f
  done
#+END_SRC

#+RESULTS:
| Flattening | f469n  |
| Flattening | f487n  |
| Flattening | f502n  |
| Flattening | f547m  |
| Flattening | fq575n |
| Flattening | f656n  |
| Flattening | f658n  |
| Flattening | fq672n |
| Flattening | f673n  |
| Flattening | fq674n |
**** Comparing profiles by eye
:PROPERTIES:
:ID:       B1BF9964-0468-480C-8A10-B1885B5A2006
:END:
+ Took some profiles by eye on WFC3 and MUSE images of F547M
  + Cannot compare them in DS9 because the spatial axis is written in pixels, which are different sizes 
+ [[file:muse-f547m-cut.dat]]
+ [[file:wfc3-f547m-cut.dat]]
** TODO [3/4] Compare the real and predicted count-rate images on a common grid
+ We want to put everything on the MUSE pixel grid, since that will make smaller files by a factor of src_calc{(0.2/0.03962)**2} {{{results(=25.4818555174=)}}}
+ We could use
  1. astrodrizzle
     - [[file:~/Dropbox/OrionHST-2012/HST-ACS/acs-ramp-filters.org][acs-ramp-filters.org]]
  2. montage
     - [[https://montage-wrapper.readthedocs.org]]
     - I had already done that in the t-squared [[id:A237AB1D-270E-497F-BB6B-2FD78C43E668][project]]
     - And I hadn't even used the python bindings
*** DONE Check that I have a working Montage installation
CLOSED: [2015-10-14 Wed 09:10]
+ I already have version 3.3 but version 4 is out
+ Cloning from github into [[file:~/Source/Montage/]]
+ Compiled with =make -j8= - that was fast!
*** DONE Testing out Montage
CLOSED: [2015-10-14 Wed 09:10]
#+BEGIN_SRC sh :results verbatim
PATH=$PATH:~/Source/Montage/bin
err=$(mProjectPP --help)
echo $err
#+END_SRC

#+RESULTS:
: [struct stat="ERROR", msg="Usage: mProjectPP [-z factor][-d level][-b border][-s statusfile][-o altout.hdr][-i altin.hdr][-h hdu][-x scale][-w weightfile][-t threshold][-X(expand)] in.fits out.fits template.hdr"]
*** DONE Script to resample WFC3 image onto MUSE grid
CLOSED: [2015-10-14 Wed 09:12]
+ Header for MUSE full frame grid: [[file:muse-full-frame.hdr]]
+ This does not expand the WFC3 image beyond its original borders
  + So we will have to extract a section of the MUSE image for comparison
  + On the other hand, it does maintain the same reference pixel
    + But with different values of CRPIX because the image lower left corner is different
    + So it has the same values of CRVAL
    + This will make it easy to slice the MUSE image
+ Smoothing needs to be improved
  + No smoothing is too little
  + The =s120= images that I already have are too much (this was 1.2 arcsec I assume)
  + In the [[id:2E0AC321-C544-4E65-9D59-9A11F96E94BD][t2 notes]] I calculated FWHM of 4 pixels = 0.8 arcsec
  + Actually 0.7 arcsec was better - this is now done in [[id:0CF5E394-36D0-4589-9E02-93EEDE7CF151][the orion-t2.org notes]]
#+BEGIN_SRC sh :tangle wfc3-resample-to-muse.sh
F=$1
MDIR=~/Source/Montage/bin
TDIR=~/Work/RubinWFC3/Tsquared
$MDIR/mProjectPP -h 0 -X $TDIR/full_${F}-s070.fits wfc3-resample-muse-$F.fits muse-full-frame.hdr
#+END_SRC

Test with a single image
#+BEGIN_SRC sh :results verbatim
time sh wfc3-resample-to-muse.sh F547M 2>&1 
#+END_SRC

#+RESULTS:
: [struct stat="OK", time=3]


Do all of the images
#+BEGIN_SRC sh :results verbatim
  FILTERS="f469n f487n f502n f547m fq575n f656n f658n fq672n f673n fq674n"
  for f in $FILTERS; do
      echo "Resampling $f"
      time sh wfc3-resample-to-muse.sh $f
  done
#+END_SRC

#+RESULTS:
#+begin_example
Resampling f469n
[struct stat="OK", time=4]
Resampling f487n
[struct stat="OK", time=3]
Resampling f502n
[struct stat="OK", time=5]
Resampling f547m
[struct stat="OK", time=4]
Resampling fq575n
[struct stat="OK", time=4]
Resampling f656n
[struct stat="OK", time=5]
Resampling f658n
[struct stat="OK", time=4]
Resampling fq672n
[struct stat="OK", time=4]
Resampling f673n
[struct stat="OK", time=5]
Resampling fq674n
[struct stat="OK", time=4]
#+end_example
*** TODO Crop MUSE image to the WFC3 field
This is the final step required before we can do things like take ratio maps or calculate 2d histogram images
#+BEGIN_SRC python :tangle crop_muse.py
  import sys
  import numpy as np
  from astropy.io import fits
  from astropy.wcs import WCS

  def crop_muse_to_wfc3(fid):
      """Cut out a section of the MUSE image to match the WFC3 field"""
      wname = 'wfc3-resample-muse-{}.fits'.format(fid)
      mname = 'muse-hr-image-wfc3-{}.fits'.format(fid)
      whdu = fits.open(wname)[0]
      mhdu = fits.open(mname)['DATA']
      wcs_w = WCS(whdu.header).celestial
      wcs_m = WCS(mhdu.header).celestial
      # Check that the two images have the same reference point in RA, DEC
      assert np.all(wcs_w.wcs.crval == wcs_m.wcs.crval)
      # And that the pixel scales are the same
      assert np.all(wcs_w.wcs.cdelt == wcs_m.wcs.cdelt)
      assert np.all(wcs_w.wcs.pc == wcs_m.wcs.pc)

      # The shapes of the two grids: (nx, ny) in FITS axis order
      shape_w = np.array([whdu.header['NAXIS1'], whdu.header['NAXIS2']])
      shape_m = np.array([mhdu.header['NAXIS1'], mhdu.header['NAXIS2']])
  
      # The difference in CRPIX values tells us the start indices (i, j)
      # for the crop window on the MUSE grid. Note that this is in
      # zero-based array indices
      start = wcs_m.wcs.crpix - wcs_w.wcs.crpix
      # The stop indices for the crop window 
      stop = start + shape_w
      
      # Shift 1 pixel to the right to do a coarse alignment correction
      start[0] += 1
      stop[0] += 1

      # Check that these are within bounds of the original MUSE grid
      assert np.all(start >= 0.0)
      assert np.all(stop < shape_m)
  
      # Crop the MUSE data array to the start:stop indices, remembering
      # that python axis order is backwards with respect to FITS axis
      # order
      mhdu.data = mhdu.data[start[1]:stop[1], start[0]:stop[0]]

      # And copy the WFC3 wcs into the new MUSE header
      mhdu.header.update(wcs_w.to_header())

      # Write out the new cropped MUSE image
      oname = mname.replace('-image-', '-cropimage-')
      mhdu.writeto(oname, clobber=True)

      return oname


  if __name__ == '__main__':
      try:
          filter_id = sys.argv[1]
      except:
          print('Usage:', sys.argv[0], 'FILTER')

      print(crop_muse_to_wfc3(filter_id))
  
#+END_SRC

#+BEGIN_SRC sh :results silent
python crop_muse.py f547m
#+END_SRC

#+BEGIN_SRC sh :results verbatim
  FILTERS="f469n f487n f502n f547m fq575n f656n f658n fq672n f673n fq674n"
  for f in $FILTERS; do
      time python crop_muse.py $f
  done
#+END_SRC

#+RESULTS:
#+begin_example
muse-hr-cropimage-wfc3-f469n.fits
muse-hr-cropimage-wfc3-f487n.fits
muse-hr-cropimage-wfc3-f502n.fits
muse-hr-cropimage-wfc3-f547m.fits
muse-hr-cropimage-wfc3-fq575n.fits
muse-hr-cropimage-wfc3-f656n.fits
muse-hr-cropimage-wfc3-f658n.fits
muse-hr-cropimage-wfc3-fq672n.fits
muse-hr-cropimage-wfc3-f673n.fits
muse-hr-cropimage-wfc3-fq674n.fits
#+end_example

** Visualizations of throughput calibration quality
The final count-rate images to be compared are 
+ Smoothed WFC3 :: wfc3-resample-muse-FILTER.fits
+ Cropped MUSE :: muse-hr-cropimage-wfc3-FILTER.fits
*** Ratios of the images
+ This will allow us to see how important misalignment is, and if there are any spatial trends

#+BEGIN_SRC python
  from astropy.io import fits

  filters_ = ["FQ575N", "FQ672N", "FQ674N", "F673N", "F469N",
              "F487N", "F656N", "F658N", "F547M", "F502N"]

  def divide_fits_images(name1, name2, outname):
      hdu1 = fits.open(name1)[0]
      hdu2 = fits.open(name2)['DATA']
      fits.PrimaryHDU(header=hdu1.header, data=hdu1.data/hdu2.data).writeto(outname, clobber=True)

  if __name__ == '__main__':
      for f in filters_:
          divide_fits_images(
              'wfc3-resample-muse-{}.fits'.format(f),
              'muse-hr-cropimage-wfc3-{}.fits'.format(f),
              'wfc3-over-muse-calib-ratio-{}.fits'.format(f)
          )
    
#+END_SRC

#+RESULTS:
: None


*** Two-d histogram of WFC3 vs MUSE-predicted count rates

#+BEGIN_SRC python :tangle histocalib.py
  from __future__ import print_function
  import numpy as np
  from astropy.io import fits
  from astropy.convolution import convolve, Gaussian2DKernel
  from matplotlib import pyplot as plt
  import seaborn as sns

  maxcount = {
      "fq575n": 0.4,
      "fq672n": 0.6,
      "fq674n": 0.75,
      "f673n" : 2.5,
      "f469n" : 0.5,
      "f487n" : 10.0,
      "f656n" : 40.0, 
      "f658n" : 11.0, 
      "f547m" : 7.0, 
      "f502n" : 20.0,
  }
  GAMMA = 2.0

  cmap = sns.light_palette((260, 50, 30), input="husl", as_cmap=True)
  # cmap = plt.cm.gray_r

  def histogram_calib_images(f, vmax=1.0):
      name1 = 'wfc3-resample-muse-{}.fits'.format(f)
      name2 = 'muse-hr-cropimage-wfc3-{}.fits'.format(f)
      pltname = 'wfc3-vs-muse-calib-{}.pdf'.format(f)
      hdu1 = fits.open(name1)[0]
      hdu2 = fits.open(name2)['DATA']
      hduc = fits.open('wfc3-resample-muse-f547m.fits')[0]
      x, y = hdu2.data, hdu1.data
      xmin, xmax = ymin, ymax = 0.0, vmax
      ew = y/hduc.data
      # mask out silly values
      m = np.isfinite(x) & np.isfinite(y/x) & (np.abs(np.log10(y/x)) < 1.0)
      H, xedges, yedges = np.histogram2d(x[m], y[m], 200,
                                         [[xmin, xmax], [ymin, ymax]],
                                         weights=y[m])
      # Fit a straight line
      mm = m & (x > 0.05*xmax) & (y > 0.05*ymax) & (x < 0.5*xmax) & (y < 0.5*ymax) & (np.abs(np.log10(y/x)) < 0.3)
      # First, linear fit y(x) = m x + c
      y_x_linfit = np.polyfit(x[mm], y[mm], 1, w=y[mm])
      # Second, linear fit x(y) = m y + c
      x_y_linfit = np.polyfit(y[mm], x[mm], 1, w=y[mm])
      # Convert this from x(y) -> y(x)
      # If x = m y + c, then y = (1/m) x - c/m
      y_x_altfit = np.array([1./x_y_linfit[0], -x_y_linfit[1]/x_y_linfit[0]])
      # Take average and spread of these two fits
      y_x_bestfit = 0.5*(y_x_linfit + y_x_altfit)
      y_x_errfit = 0.5*np.abs(y_x_linfit - y_x_altfit)

      pbest =  np.poly1d(y_x_bestfit)

      # H = convolve(H, Gaussian2DKernel(1.0))
      fitcolor = (1.0, 0.5, 0.0)
      fitlabel = "y = ({:.2f} +/- {:.2f}) x + ({:.2f} +/- {:.2f})".format(
          y_x_bestfit[0], y_x_errfit[0], y_x_bestfit[1], y_x_errfit[1])
      fig, ax = plt.subplots(1, 1)
      ax.imshow((H.T)**(1.0/GAMMA), extent=[xmin, xmax, ymin, ymax],
                interpolation='none', aspect='auto', origin='lower', 
                cmap=cmap, alpha=1.0)
      ax.plot([0.0, x[m].max()], [0.0, x[m].max()], '-', alpha=1.0,
              lw=1, c='w', label=None)
      ax.plot([0.0, x[m].max()], pbest([0.0, x[m].max()]), '-', alpha=1.0,
              lw=1, c=fitcolor, label=fitlabel)

      leg = ax.legend(loc='upper left', title='Linear Fit', frameon=True, fancybox=True)
      leg.get_title().set_fontsize('small')
      ax.set_ylabel(
          'Observed WFC3 {} count rate, electron/s/pixel'.format(f.upper()))
      ax.set_xlabel(
          'MUSE-predicted WFC3 {} count rate, electron/s/pixel'.format(f.upper()))
      ax.set_xlim(xmin, xmax)
      ax.set_ylim(ymin, ymax)

      # Now do 1-D histogram of the deviations from the model
      ratio = y/pbest(x)
      if f == 'f547m':
          # Divide into high and low continuum counts
          s = 'counts'
          mlo = (y < y[m].mean()) & m
          mhi = (y >= y[m].mean()) & m
      else:
          # Divide into high and low EW
          s = 'EW'
          mlo = (ew < np.median(ew[m])) & m
          mhi = (ew >= np.median(ew[m])) & m

      assert mlo.sum() > 0, f
        
      # inset axis at the bottom right
      ax2 = fig.add_axes([0.6, 0.2, 0.25, 0.25])
      ax2.hist(ratio[mlo], bins=100, range=(0.5, 1.5),
               normed=True, weights=y[mlo], alpha=0.7, label='Low '+s)
      ax2.hist(ratio[mhi], bins=100, range=(0.5, 1.5),
               normed=True, weights=y[mhi], color='red', alpha=0.3, label='High '+s)
      ax2.set_xlim(0.5, 1.5)
      ax2.legend(loc='upper left', fontsize='xx-small')
      ax2.tick_params(labelleft=False, labelsize='x-small')
      ax2.set_xlabel('(Observed Counts) / (Linear Fit)', fontsize='xx-small')
      ax2.set_ylabel('Weighted PDF Histograms', fontsize='xx-small')
  #    ax2.set_title('PDF', fontsize='x-small')
      fig.set_size_inches(7, 7)
      fig.savefig(pltname)

      return [pltname, fitlabel]


  if __name__ == '__main__':
      for f, vmax in maxcount.items():
          print(histogram_calib_images(f, vmax))

#+END_SRC

#+RESULTS:


#+BEGIN_SRC sh
python histocalib.py 
#+END_SRC

#+RESULTS:
| ['wfc3-vs-muse-calib-f487n.pdf'  | 'y = (0.99 +/- 0.01) x + (-0.02 +/- 0.02)'] |
| ['wfc3-vs-muse-calib-f658n.pdf'  | 'y = (1.00 +/- 0.01) x + (-0.02 +/- 0.02)'] |
| ['wfc3-vs-muse-calib-f469n.pdf'  | 'y = (0.94 +/- 0.03) x + (-0.00 +/- 0.01)'] |
| ['wfc3-vs-muse-calib-fq674n.pdf' | 'y = (0.98 +/- 0.01) x + (0.01 +/- 0.00)']  |
| ['wfc3-vs-muse-calib-f656n.pdf'  | 'y = (1.02 +/- 0.01) x + (0.18 +/- 0.07)']  |
| ['wfc3-vs-muse-calib-fq672n.pdf' | 'y = (0.97 +/- 0.02) x + (0.01 +/- 0.00)']  |
| ['wfc3-vs-muse-calib-fq575n.pdf' | 'y = (1.00 +/- 0.02) x + (-0.00 +/- 0.00)'] |
| ['wfc3-vs-muse-calib-f673n.pdf'  | 'y = (0.97 +/- 0.01) x + (0.02 +/- 0.01)']  |
| ['wfc3-vs-muse-calib-f547m.pdf'  | 'y = (1.01 +/- 0.01) x + (-0.11 +/- 0.03)'] |
| ['wfc3-vs-muse-calib-f502n.pdf'  | 'y = (0.98 +/- 0.01) x + (-0.01 +/- 0.04)'] |


*** Summary of calibration results
+ Calibration constant is unity in most cases!
  + Exceptions are
    + F469N :: slope = 0.94
    + F673N :: slope = 0.97
    + F547M :: intercept = -0.11
+ Also no evidence of trend with EW


** Useful scripts
:PROPERTIES:
:header-args: :results silent
:END:
#+name: new-blank-ds9
#+BEGIN_SRC sh :results silent :var DS9="ds9"
open -n -a SAOImage\ DS9 --args -title $DS9
sleep 1
xpaset -p $DS9 view buttons no
xpaset -p $DS9 frame delete all
#+END_SRC

#+call: new-blank-ds9() :results silent

#+BEGIN_SRC sh
xpaset -p ds9 frame new
xpaset -p ds9 fits $PWD/muse-hr-data-wavsec3.fits
#+END_SRC

#+RESULTS:

* Exploring the data cubes
** Original data locations
At CRyA in =/fs/nil/other0/will/orion-muse/DATA= 
+ LR :: 1.25 Angstrom sampling: DATACUBEFINALuser_20140216T010259_cf767044.fits
+ HR :: 0.85 Angstrom sampling: DATACUBEFINALuser_20140216T010259_78380e1d.fits
*** LR cube
+ Dimensions:
  + NV = 3818
  + NY = 1476
  + NX = 1766
+ Scales:
  + Spatial: 0.2 arcsec
  + Wavelength: 1.25 Ang
**** Reading in the cube
#+BEGIN_SRC python
from astropy.io import fits
from astropy import wcs
import numpy as np
hdulist = fits.open('DATA/DATACUBEFINALuser_20140216T010259_cf767044.fits')
cube = hdulist['DATA']
#+END_SRC
Note that this does not read the full data cube (40 GB) into memory unless we need to do something with it.
**** Extracting the Orion S region
+ To start with, we will look at a 300x300 box centered on (1050, 550)
+ This is more or less the quad filter region
#+BEGIN_SRC python
  subcube = cube.data[:, 400:700, 900:1200]
  spec = np.nansum(np.nansum(subcube, axis=-1), axis=-1)
  spechdu = fits.PrimaryHDU(header=cube.header, data=spec.reshape((3818, 1, 1)))
  spechdu.writeto('subcube-spec.fits')
#+END_SRC
+ So this gives the summed spectrum of the region
+ Note that I did a reshape on the array so that wavelength is still the 3rd FITS axis.  So that the header WCS keywords don't need changing 
#+BEGIN_SRC sh
rsync -avzP nil:/fs/nil/other0/will/orion-muse/subcube-spec.fits .
#+END_SRC
+ The spectrum shows up as s single pixel in ds9, but you can see a graph of it by using a region
*** HR cube
+ Exactly the same, except that NV = 5614
  + Wavelength scale: 0.85 angstroms
  + CRPIX3 = 1
  + CRVAL3 = 4595.
+ First try at dividing it up: do it by wavelength
  + Divide into 8 parts of length 702
    + Last one will be 700
  + Size will be 0.702 1.476 1.766 4 = 7.32 GB

  | Section |  CRVAL3 |
  |---------+---------|
  |       0 | 4595.00 |
  |       1 | 5191.70 |
  |       2 | 5788.40 |
  |       3 | 6385.10 |
  |       4 | 6981.80 |
  |       5 | 7578.50 |
  |       6 | 8175.20 |
  |       7 | 8771.90 |
  #+TBLFM: $2=4595.0 + 0.85 702 $1 ;f2

#+BEGIN_SRC python
  from astropy.io import fits
  from astropy import wcs
  import numpy as np

  hdulist = fits.open('DATA/DATACUBEFINALuser_20140216T010259_78380e1d.fits')
  datcube = hdulist['DATA']
  errcube = hdulist['STAT']
  sections = np.arange(8, dtype=int)
  NV = 702
  k1_list = sections*NV
  k2_list = k1_list + NV
  wav0_list = datcube.header['CRVAL3'] + datcube.header['CD3_3']*NV*sections
  for section, k1, k2, wav0 in zip(sections, k1_list, k2_list, wav0_list):
      fn = 'muse-hr-data-wavsec{}.fits'.format(section)
      hdr = datcube.header.copy()
      hdr['CRVAL3'] = wav0
      hdr['NAXIS3'] = NV
      print('Writing', fn)
      fits.PrimaryHDU(header=hdr, data=datcube.data[k1:k2]).writeto(fn)
  
#+END_SRC
*** Heliocentric correction
Again, these snippets need to be run on the CRyA server where the big data cubes are
**** Looking for keywords in the top-level header
#+BEGIN_SRC python
hdr = hdulist[0].header
hdr.tofile('HRcube.hdr', sep='\n', padding=False)
#+END_SRC

#+RESULTS:

#+BEGIN_EXAMPLE
SIMPLE  =                    T / file does conform to FITS standard             
BITPIX  =                    8 / number of bits per data pixel                  
NAXIS   =                    0 / number of data axes                            
EXTEND  =                    T / FITS dataset may contain extensions            
COMMENT   FITS (Flexible Image Transport System) format is defined in 'Astronomy
COMMENT   and Astrophysics', volume 376, page 359; bibcode: 2001A&A...376..359H 
DATE    = '2014-11-13T08:54:24' / file creation date (YYYY-MM-DDThh:mm:ss UT)   
ORIGIN  = 'TEST    '           / European Southern Observatory                  
TELESCOP= 'ESO-VLT-U4'         / ESO <TEL>                                      
INSTRUME= 'MUSE    '           / Instrument used.                               
RA      =            83.780509 / [deg] 05:35:07.3 RA (J2000) pointing           
DEC     =             -5.39556 / [deg] -05:23:44.0 DEC (J2000) pointing         
EQUINOX =                2000. / Standard FK5                                   
RADECSYS= 'FK5     '           / Coordinate system                              
EXPTIME =                   5. / Integration time                               
MJD-OBS =       56704.04374097 / Obs start                                      
DATE-OBS= '2014-02-16T01:02:59.219' / Observing date                            
UTC     =                3770. / [s] 01:02:49.000 UTC                           
LST     =             21901.85 / [s] 06:05:01.850 LST                           
PI-COI  = 'UNKNOWN '           / PI-COI name.                                   
OBSERVER= 'UNKNOWN '           / Name of observer.                              
PIPEFILE= 'DATACUBE_FINAL.fits' / Filename of data product                      
BUNIT   = '10**(-20)*erg/s/cm**2/Angstrom'                                      
DATAMD5 = '69173383d3718d3ddb46e187f4cc2954' / MD5 checksum                     
OBJECT  = 'M42-lr  '           / Original target.                               
CHECKSUM= 'NcfSOcZPNcdPNcZP'   / HDU checksum updated 2014-11-12T22:17:16       
DATASUM = '0       '           / data unit checksum updated 2014-11-12T22:17:16 
HIERARCH ESO OBS AIRM =     5. / Req. max. airmass                              
HIERARCH ESO OBS AMBI FWHM = 2. / Req. max. seeing 
... ETC ...        
#+END_EXAMPLE

So, this does have the info that we need: RA, DEC, MJD-OBS in particular
